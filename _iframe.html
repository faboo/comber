<!DOCTYPE html>
<html>
<head>
    <title>Comber</title>
    <meta charset="utf-8" />
</head>
<body>
    <section id="comber">
        <h1>Comber</h1>
        <p>Comber is a parser combinator library for creating text parsers in plain Python with a BNF flavor.</p>
        <p>For instance, we could define a simple grammar for calling functions on integer values like this:</p>
        <pre data-language="python"><span class="kn">from</span> <span class="nn">comber</span> <span class="kn">import</span> <span class="n">C</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="n">inf</span>

<span class="n">keyword</span> <span class="o">=</span> <span class="n">rs</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[_a-zA-Z][_a-zA-Z0-9]*&#39;</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="s1">&#39;keyword&#39;</span><span class="p">)</span>
<span class="n">number</span> <span class="o">=</span> <span class="n">rs</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9]+&#39;</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">keyword</span> <span class="o">|</span> <span class="n">number</span>
<span class="n">package</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">]</span>
<span class="n">import_statement</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;import&#39;</span> <span class="o">+</span> <span class="n">package</span>
<span class="n">function_call</span> <span class="o">=</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">value</span><span class="o">**</span><span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
<span class="n">assignment</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;let&#39;</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span>
<span class="n">grammar</span> <span class="o">=</span> <span class="p">(</span><span class="n">import_statement</span> <span class="o">|</span> <span class="n">assignment</span> <span class="o">|</span> <span class="n">function_call</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">]</span></pre>
        <p>Our toy grammar can handle simple import statements, variable assignment, and function calling. For example:</p>
        <pre>import math
import sys.io

let user_number = read()
let double = multiple(user_number, 2)

print(double)</pre>
        <p>To use our parser, we simply pass a string to it:</p>
        <pre data-language="python"><span class="kn">from</span> <span class="nn">comber</span> <span class="kn">import</span> <span class="n">ParseError</span>

<span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;add(17, 3)&quot;</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">parseState</span> <span class="o">=</span> <span class="n">grammar</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Parsed tokens: </span><span class="si">{</span><span class="n">parseState</span><span class="o">.</span><span class="n">tree</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ParseError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span></pre>
        <p>The <cite>grammar</cite> call returns the final parser state on a successful parse, from which you can retrieve the final parse tree. In our case, it is effectively a list:</p>
        <pre>['add', '(', 17, 3, ')']</pre>
        <p>Our grammar only supports variables and integers. Suppose we tried to assign pythong-style string to a variable:</p>
        <pre>let text = "Here's some text"</pre>
        <p>If we tried to parse this, we'd get an exception like:</p>
        <pre>1:12: Unexpected Text: "Here's som. Expected one of: @keyword, @number</pre>
        <aside id="contents" class="topic contents">
            <h1>Contents</h1>
            <ul>
                <li><a href="#building-parsers">Building Parsers</a>
                    <ul>
                        <li><a href="#the-c-parser">The C Parser</a></li>
                        <li><a href="#basic-combinators">Basic Combinators</a></li>
                        <li><a href="#repetition">Repetition</a></li>
                        <li><a href="#recursive-grammars">Recursive Grammars</a></li>
                    </ul>
                </li>
                <li><a href="#building-parse-trees">Building Parse Trees</a></li>
                <li><a href="#error-handling">Error Handling</a></li>
                <li><a href="#pitfalls">Pitfalls</a></li>
                <li><a href="#todo">TODO</a>
                    <ul>
                        <li><a href="#available-operators">Available Operators</a></li>
                    </ul>
                </li>
            </ul>
        </aside>
        <section id="building-parsers">
            <h2>Building Parsers</h2>
            <p>The most basic parsers are string literals (which match exactly), <cite>rs</cite> for matching a regular expression, and <cite>cs</cite> for matching any of the strings of an iterable.</p>
            <p>The <cite>rs</cite> parser can be seen in our toy grammar above. Standard Python regular expressions are supported. The entire match is used as the result of the parse, regardless of groupings etc.</p>
            <p>The <cite>cs</cite> parse takes any iterable of strings. The first string that exactly matches (the start of) the input text. If none of the strings match, the parse fails. Since strings are themselves iterables, we could add addition and subtraction to our toy grammar like this:</p>
            <pre data-language="python"><span class="kn">from</span> <span class="nn">comber</span> <span class="kn">import</span> <span class="n">C</span><span class="p">,</span> <span class="n">cs</span>

<span class="n">addition</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="n">cs</span><span class="p">(</span><span class="s1">&#39;+-&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">value</span>
<span class="n">assignment</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;let&#39;</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">addition</span> <span class="o">|</span> <span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span></pre>
            <p>String literals can only be used in combination with other parsers. If a string literal would start a sequence, or otherwise appear alone, make use of the C parser.</p>
            <section id="the-c-parser">
                <h3>The C Parser</h3>
                <p>The C parser, on its own, consumes no text, produces no tokens, and always succeeds. It's most useful for starting a parser that would otherwise begin with a string literal. E.g. this:</p>
                <pre data-language="python"><span class="s1">&#39;let&#39;</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span></pre>
                <p>would actually throw a Python error because 'let' isn't <em>really</em> a parser - yet! That's where <cite>C</cite> comes in:</p>
                <pre data-language="python"><span class="n">C</span><span class="o">+</span> <span class="s1">&#39;let&#39;</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span></pre>
                <p><cite>C</cite> starts off the sequence, so we can use any combination of parsers and string literals we like from there. It works similarly with alternatives, so if we wanted to allow <cite>set</cite> to be used as a synonym for <cite>let</cite>, we might do:</p>
                <pre data-language="python"><span class="p">(</span><span class="n">C</span><span class="o">|</span> <span class="s1">&#39;let&#39;</span><span class="o">|</span><span class="s1">&#39;set&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">keyword</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)</span></pre>
                <p><cite>C</cite> can also be used to wrap a parser to protect it from optimization; for instance, embedding one sequence or alternative set inside another. If, for instance, we extended our grammar to allow a bare value to be a whole statement:</p>
                <pre data-language="python"><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyword</span> <span class="o">|</span> <span class="n">number</span><span class="p">)</span><span class="o">@</span><span class="s1">&#39;value&#39;</span>
<span class="n">grammar</span> <span class="o">=</span> <span class="p">(</span><span class="n">import_statement</span> <span class="o">|</span> <span class="n">assignment</span> <span class="o">|</span> <span class="n">function_call</span> <span class="o">|</span> <span class="n">value</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">]</span></pre>
            </section>
            <section id="basic-combinators">
                <h3>Basic Combinators</h3>
                <p>Parsers can be combined in series with <cite>+</cite>:</p>
                <pre data-language="python"><span class="n">name</span> <span class="o">+</span> <span class="n">address</span> <span class="o">+</span> <span class="n">pet</span></pre>
                <p>A sequence of parsers is evaluated left to right, each consuming text before the next is evaluated. If at any point in the sequence a parser fails, the entire sequence fails.</p>
                <p>A set of alternatives is built with <cite>|</cite>:</p>
                <pre data-language="python"><span class="n">name</span> <span class="o">|</span> <span class="n">idnumber</span> <span class="o">|</span> <span class="n">location</span></pre>
                <p>Alternatives are considered left to right, with the first successful match being the match for the entire set. Be careful! This means that for some sets of alternatives, the "obvious" parser may not be the one used, simply because it came after another match.</p>
                <p>Both sequences and alternatives will flatten like combinators, such that:</p>
                <pre data-language="python"><span class="n">name</span> <span class="o">=</span> <span class="n">firstname</span> <span class="o">+</span> <span class="n">lastname</span>
<span class="n">salutation</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span></pre>
                <p>is equivalent to:</p>
                <pre data-language="python"><span class="n">salutation</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="n">firstname</span> <span class="o">+</span> <span class="n">lastname</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span></pre>
                <p>If you need to mantain the logical separation (to parse correctly, or maintain the name of a subparser), wrap the subparser with <cite>C</cite>:</p>
                <pre data-language="python"><span class="n">name</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">firstname</span> <span class="o">+</span> <span class="n">lastname</span><span class="p">)</span>
<span class="n">salutation</span> <span class="o">=</span> <span class="n">C</span><span class="o">+</span> <span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span></pre>
            </section>
            <section id="repetition">
                <h3>Repetition</h3>
                <p>The most flexible option for specifying repetition is brackets:</p>
                <pre data-language="python"><span class="n">keyword</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">]</span></pre>
                <p>The above would parse <cite>keyword</cite> zero to ten times, separated by a comma. The separator is optional - without it, the result would simply parse <cite>keyword</cite> zero to ten times.</p>
                <p>We could also specify parsing an exact number of times:</p>
                <pre data-language="python"><span class="n">keyword</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span></pre>
                <p>Or, with a separator:</p>
                <pre data-language="python"><span class="n">keyword</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">]</span></pre>
                <p>Infinity - <cite>math.inf</cite> - is a valid maximum value. For convenience, it can be imported directly from Comber:</p>
                <pre data-language="python"><span class="kn">from</span> <span class="nn">comber</span> <span class="kn">import</span> <span class="n">inf</span>

<span class="n">param_list</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">]</span></pre>
                <p>There are several convenience combinators for common types of repetition.</p>
                <p>For zero or more with a separator, using <cite>**</cite>:</p>
                <pre data-language="python"><span class="n">parser</span><span class="o">*</span><span class="s1">&#39;,&#39;</span></pre>
                <p>Or zero or more without a separator, using the unary <cite>+</cite>:</p>
                <pre data-language="python"><span class="o">+</span><span class="n">parser</span></pre>
                <p>You can declare a parser as <em>optional</em> with <cite>~</cite>:</p>
                <pre data-language="python"><span class="o">~</span><span class="n">parser</span></pre>
            </section>
            <section id="recursive-grammars">
                <h3>Recursive Grammars</h3>
            </section>
        </section>
        <section id="building-parse-trees">
            <h2>Building Parse Trees</h2>
        </section>
        <section id="error-handling">
            <h2>Error Handling</h2>
        </section>
        <section id="pitfalls">
            <h2>Pitfalls</h2>
            <p>Under the covers, Comber is essentially a recursive descent parser. It's best suited for relatively shallow grammars parsing small amounts of text.</p>
        </section>
        <section id="todo">
            <h2>TODO</h2>
            <section id="available-operators">
                <h3>Available Operators</h3>
                <p>Operators that Python allows to overridden</p>
                <table>
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Method</th>
                            <th>Current use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>+</td>
                            <td>__add__</td>
                            <td>sequences</td>
                        </tr>
                        <tr>
                            <td>|</td>
                            <td>__or__</td>
                            <td>selection</td>
                        </tr>
                        <tr>
                            <td>[ ]</td>
                            <td>__getitem__</td>
                            <td>repeat</td>
                        </tr>
                        <tr>
                            <td>@</td>
                            <td>__matmul__</td>
                            <td>names and internalization</td>
                        </tr>
                        <tr>
                            <td>&lt;</td>
                            <td>__lt__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&gt;</td>
                            <td>__gt__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&lt;=</td>
                            <td>__le__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&gt;=</td>
                            <td>__ge__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>==</td>
                            <td>__eq__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>!=</td>
                            <td>__ne__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>is</td>
                            <td>_is</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>is not</td>
                            <td>is_not</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>-</td>
                            <td>__sub__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>%</td>
                            <td>__mod__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>*</td>
                            <td>__mul__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>**</td>
                            <td>__pow__</td>
                            <td>zero or more, with provided separator</td>
                        </tr>
                        <tr>
                            <td>/</td>
                            <td>__truediv__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>//</td>
                            <td>__floordiv__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&amp;</td>
                            <td>__and__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>^</td>
                            <td>__xor__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&lt;&lt;</td>
                            <td>__lshift__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&gt;&gt;</td>
                            <td>__rshift__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>in</td>
                            <td>__contains__</td>
                            <td></td>
                        </tr>
                    </tbody>
                </table>
                <p>Unary operators:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Method</th>
                            <th>Current use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>~</td>
                            <td>__invert__</td>
                            <td>optional</td>
                        </tr>
                        <tr>
                            <td>not</td>
                            <td>__not__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>-</td>
                            <td>__neg__</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>+</td>
                            <td>__pos__</td>
                            <td>zero or more</td>
                        </tr>
                    </tbody>
                </table>
                <p>And:</p>
                <pre>()        __call__   parse a string</pre>
            </section>
        </section>
    </section>
</body>
</html>